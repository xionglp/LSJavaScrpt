面试常考知识点:
一、JS的数据类型有哪些
 - 基本数据类型(值类型): Number、String、Boolean、Null、Undefined、BigInt、Symbol
 - 复杂数据类型（引用类型）: Object、Function、Array、Date
 - 基本数据类型保存在栈里面，可以直接访问它的值；
 - 引用数据类型保存在堆里面，栈中保存的只是它的地址，通过栈里面的地址去访问堆里面的值。
 - 附加: null和Undefined的区别: null表示一个对象被定义了，但是是空值，Undefined表示不存在这个值。此处应该有一个值，但是还未定义。

二、如何判断JS的数据类型
 1、typeof
  - typeof可以区分除了Null类型以外的其他基本数据类型，以及从对象类型中识别出函数(function)
  - typeof null 返回的是 "object"。 可以使用 === 全等运算符来判断。
 2、instanceof
  - instanceof一般用来判断引用数据类型，但是不能正确判断基本数据类型。
  - 原理是根据在原型链中查找判断当前数据的原型对象是否存在返回布尔类型。
 3、Object.prototype.toString.call() 来正确判断JS的数据类型
 4、Array.isArray(value)可以判断是否是一个数组

三、 == 和 === 的区别
 1、== 俩个等号为等值符，当等号俩边的值类型不同的时候，会发生类型的自动转换，转换为相同类型再做比较
 2、=== 三个等号为等同符，若等号两边值的类型不同时直接返回 false， ===三个等号既要判断类型也要判断值是否相等。

四、如何变量对象的属性
 - 遍历自身可枚举属性（可枚举、非继承属性） Object.keys()
 - 遍历自身的所有属性（可枚举、不可枚举、非继承属性） Object.getOwnPropertyNames()
 - 遍历可枚举的自身属性和继承属性 for...in
 - 附加: 判断俩个对象是否相等: Object.is(obj1, obj2) => 俩个对象是否指向同一个内存地址。

五、作用域和作用域链 
 - 作用域: 即变量和函数能被访问的区域或集合，一般可分为: 全局作用域、局部作用域（函数作用域）、块级作用域
 - 作用域链: 当在JS中使用变量时，JS引擎会尝试在当前作用域下查找该变量，如果没有找到，再到它的上层作用域寻找，
 直到找到该变量或者查找至全局作用域。
 - JS采用的是静态作用域，函数作用域在函数定义的时候就确定了，和函数在哪个位置调用没有关系。

六、this指向问题
 - 作为普通函数独立调用执行时，this指向的是window，但是在严格模式下this -> undefined
 - 函数作为对象的方法调用时，this指向的是该对象
 - 当用new运算符调用构造函数时，this指向的是返回的对象
 - 箭头函数的this绑定看的是this所在函数定义在哪个对象下，就绑定哪个对象。如果存在嵌套，绑定到最近的一层对象上。
 - call() apply() bind() 都可以显示的指定调用函数的this指向。

七、call、apply、bind的区别
 - call() 可以传递两个参数，第一个参数指定函数内部this指向，第二个参数是函数调用时需要传递的参数，改变this指向后原函数会立即执行，此方法只会临时改变this指向一次。
 - apply() 接收俩个参数，第一个参数指定this的指向，第二个参数是函数接收的参数，以数组的形式传入。改变this指向后原函数会立即执行，此方法只会临时改变this指向一次。
 - bind() 第一个参数也是this的指向，后面传入的也是一个参数列表（但是这个参数列表可以分多次传入）。改变this指向后不会立即执行，而是返回一个永久改变this指向的函数。

八、闭包
在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，可以在内层函数中访问到外层函数的作用域。
 - 闭包就是能够读取其他函数内部变量的函数。
 - 优点: 延长局部变量的生命周期。
 - 缺点: 会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏。

九、原型-原型链
 - JS 是面向对象的，每个实例对象都有一个__proto__属性，该属性指向它的原型对象。
 该实例的构造函数有一个原型属性prototype，与实例的__proto__属性指向同一个对象。同时，原型对象的constructor 指向构造函数本身。
 - 当一个对象查找一个属性时，自身没有就会根据__proto__属性向他的原型进行查找，如果还是没有，则向它的原型的原型进行查找
 直到找到Object.prototype.__proto__ 也就是null，这样形成一个原型链。

十、箭头函数
 - 箭头函数本身不绑定this，会捕获其所在的上下文的this，作为自己的this。
 - 箭头函数不能用作构造函数，也不能使用new关键字创建对象。
 - 箭头函数不绑定arguments，取而代之用rest参数。
 - 使用call、apply、bind并不会改变箭头函数中的this指向。

十一、防抖和节流
防抖:   
 - 多次触犯事件， 事件处理函数只能执行一次
 - 当一个事件被触发，准备执行事件函数前，会先等待一定的时间
 - 在这个等待的时间内，如果没有再次被触发，那么就执行，如果又触发了，那就本次作废，重置等待时间，直到最终能执行
 - 应用场景: 搜索框搜索输入，输完最后一个再发送请求，手机号、邮箱的校验
节流:
 - 事件触发后，规定的时间内（例如2s），事件处理函数不能再次被调用
 - 也就是说规定的时间内，函数只能被调用一次
 - 有频率的执行

十二、深拷贝和前拷贝
 - 深拷贝: 开辟一个新的栈，俩个对象的属性完全相同，但是对应俩个不同的内存地址。修改一个对象的属性，不会改变另一个对象的属性。
 - 浅拷贝: 如果属性是基本数据类型， 拷贝的就是基本数据类型的值。如果属性是引用类型，拷贝的就是内存地址。
   浅拷贝是拷贝一层，深层次的引用类型则共享内存地址，常用的方法有Object.assign,扩展运算符等等。

十三、script标签中async和defer的区别
 - script: 会阻断HTML解析，只有下载好并执行完脚本才会继续解析HTML
 - async script: 解析HTML的过程中会异步下载脚本，下载成功后会立即执行，因此有可能会阻断HTML解析。多个脚本的执行顺序无法保证。
 - defer script: 也是异步下载脚本，如果此时HTML还没有解析完成，浏览器不会暂停解析去执行脚本，而是等HTML解析完毕再执行js代码。
   如果存在多个defer script标签，浏览器会保证它们按照在HTML中出现的顺序执行，不会破坏JS脚本之间的依赖关系。 

十四、Array.from() 和 Array.of() 用法和区别
  - Array.from() 将伪数组对象或可遍历对象转成真数组。接收三个参数: input,map,context。
  input: 待转换的伪数组对象或可遍历对象, map: 类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组,
  context：绑定map中用到的 this.
  - Array.of() 将一系列值转换为数组，会创建一个包含所有参数的数组。

十五、new操作符的实现机制
 - 首先创建一个新的空对象
 - 设置原型，将对象的原型设置为函数的prototype对象
 - 让函数的this指向这个对象，执行构造函数的代码
 - 返回这个对象

十六、事件循环
js是单线程运行的，当遇到一个异步事件后并不会一直等待其返回结果。将其放到一个任务队列中执行。
 - 微任务队列: promise的回调、node中的process.nextTick、对DOM变化监听的MutationObserver
 - 宏任务队列: script脚本的执行、setTimeout、setInterval和setImmediate一类的定时事件、I\O操作、UI渲染
备注: 在当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。
     同一个事件循环中，微任务永远在宏任务之前执行。

十七、Promise
 - Promise是异步编程的一种解决方案。
 - Promise是一个构造函数，接收一个函数作为参数，返回一个Promise实例。
 - Promise实例有三种状态，分别是pending（进行中）、fulfilled（已成功）、rejected（已失败）
 - 实例的状态只能由 pending 转变 fulfilled 或者 rejected 状态，并且状态一经改变，就无法再改变了。
 - 状态的改变是通过resolve()和reject()来实现的。
 - Promise的原型上定义了一个then方法，使用这个then方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务。

 十八、preload和prefetch的区别

 十九、数组的相关操作
