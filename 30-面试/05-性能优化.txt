前端性能优化: 

一、首屏加载优化相关
 - 路由懒加载: import()函数，通过webpackChunkName设置分割后代码块的名字
 - 组件懒加载: import()函数，例如将弹窗组件打包成独立js文件，当用户点击按钮要弹框时才会加载这个对应js文件。
 - 合理使用Tree shaking: 消除无用的js代码，减小代码体积。依赖ES Module静态语法分析，usedExports配置标记哪些函数没有使用。
 - 骨架屏优化白屏时长: vue-skeleton-webpack-plugin插件，对比使用骨架屏前后的FP白屏时间。
 - 长列表虚拟滚动: 只渲染可视区域的列表项，非可见区域的不渲染，在滚动时动态更新可视区域。vue-virtual-scroller插件
 - Web Worker: 优化长任务
   由于浏览器GUI渲染线程与JS引擎线程是相互排斥的关系，当页面中有很多长任务时，会造成页面UI阻塞卡顿等情况。
 - JS的6种加载方式
   1. 正常模式: 默认情况下，js会阻塞DOM渲染，浏览器必须等待index.js加载和执行完后才能做其他的事情。
   2. async模式: 异步加载，js不会阻止DOM渲染，async加载时无序的
   3. defer模式: (defer推迟) js也是异步加载的，defer资源会在DOMContentLoaded执行之前，defer是有顺序的加载。
   4. module模式: 浏览器会对其内部的import引用发起http请求，获取模块内容，这时script的行为会像defer一样，在后台下载，等待DOM解析。
      vite就是利用浏览器支持原生的 es module 模块，开发时跳过打包过程，提升编译效率。
   5. preload(预加载): 用于提前加载一些需要的依赖，这些资源会提前加载。
   6. prefetch:  利用浏览器的空闲时间，加载页面将来可能用到的资源，通常用来加载其他非首页所需要的资源，以便加快后续页面的打开速度。
 - 图片的优化
   1. 图片的动态裁剪: 阿里云
   2. 图片懒加载:
      对应一些图片量比较大的首页，用户打开页面后，只需要显示屏幕可视区域内的图片，当用户滑动页面，再去加载出现在屏幕内的图片。
      由于浏览器会自动对页面中的 img 标签的 src 属性发送请求并下载图片，可以通过 html5 自定义属性 data-xxx 先暂存 src 的值，然后在图片出现在屏幕可视区域的时候，再将 data-xxx 的值重新赋值到 img 的 src 属性。
      img标签加上loading="lazy"属性
      vue-lazyload插件实现

二、了解哪些Vue的性能优化方法
 - 路由懒加载。有效拆分组件大小，访问时异步加载。 () => import(/* webpackChunkName: home */ "./xxx")
 - 组件懒加载，dialog弹框，默认不加载，弹出来显示才加载。
 - keep-alive缓存页面，避免重复创建组件实例，且能保留组件创建状态。
 - v-for遍历避免同时使用v-if。v-for的优先级比v-if的高，导致每个数据都要进行一遍v-if的判断。
 - 长列表性能优化，采用虚拟列表
 - 不再变化的数据，使用v-once指令
 - 事件销毁。组件销毁时，将全局变量和定时器也要销毁
 - 图片懒加载
 - 第三方组件按需引入
 - 子组件分割
 - SSR服务端渲染

二、打包层面性能优化